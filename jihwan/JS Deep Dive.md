# 1장 프로그래밍

## 1.1 프로그래밍이란?

- 컴퓨터를 원하는 방향으로 실행시키는 방법, 커뮤니케이션
- 무엇, 해결해야 할 문제, 요구사항을 먼저 정의해야 한다. 소프트웨어 공학이 생각나는 건 왜일까. Software Requirement Specification 작성 능력의 중요성
- 문제 해결 능력 : 알고리즘도 도움이 되며, 더 큰 범위의 능력.
- 대부분의 문제는 복잡하고 명확하지 않으므로 복잡한 것을 단순화하며 분해하고 구분 짓고 필요한 행위들을 잘 배열해내야 한다.
- 프로그래밍 : 정확하고 상세하게 요구사항을 설명하는 작업 -> 결과물로 코드가 나온다.
  - 이를 위해 컴퓨팅적 사고가 필요

## 1.2 프로그래밍 언어

- 컴퓨터에게 자연어가 아닌 기계어로 명령을 전달해야 한다. 다만 기계어는 인간이 이해하기 어려우므로 프로그래밍 언어로 작성하고, 컴파일러나 인터프리터를 통해 기계어로 번역된다.
- 프로그래밍 언어는 구문(Syntax)와 의미(Semantics)의 조합으로 표현된다. 컴퓨테이션 이론에서 배웠던 것들이 스쳐지나간다..

- 최근 LLM 및 ChatAI 들의 등장으로 프로그래밍 자체가 추상화되었다고 느낀다. 누구나 자신이 만들고 싶은 것, 해결하고 싶은 문제만 잘 쪼개어 설명한다면 코드를 짜는 것은 일반인도 가능한 시대가 되었다.

## 1.3 구문과 의미

- 노엄 촘스키 : 언어의 의미는 문맥에 있는 것이지 문법에 있는 것이 아니다
  - ex) Colorless green ideas sleep furiously
- 프로그래밍을 잘 하려면 단순히 문법만 지키는 것보단, 같은 개발자들끼리 문맥(code convention 등)을 정하고 해당 문맥 내에서 사용해야 잘 하는 것이라 볼 수 있겠다. 좋은 변수 이름을 만들고, 적당한 추상화를 하는 등.
- **프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것**이다.

# 2장 자바스크립트란?

## 2.1 자바스크립트의 탄생

- Netscape에서 브라우저에서 동작하는 경량 언어 도입하기로 하고, 1996년 Javascript로 명명한다.

## 2.2 자바스크립트의 표준화

- MS에서 Javascript 파생 버전인 JScript를 IE에 탑재하고, 표준화가 안 되면서 크로스 브라우징 이슈가 발생하기 시작했다.
- 1997년 비영리 표준화 기구 ECMA international 에서 ECMA-262, ECMAScript 1 표준화 사양을 발표했다.
  - 2015년 ES6에서 let/const, 클래스, 화살표 함수, promise, import/export 등 범용 프로그래밍 언어가 갖춰야 할 문법들이 많이 추가되었다.

## 2.3 자바스크립트 성장의 역사

### 2.3.1 Ajax

- 1999년 JS로 서버와 브라우저가 비동기적으로 데이터를 주고받을 수 있는 Ajax(Asynchronous Javascript and XML)가 등장했다.
  - 이전에는 정보를 주고받으려면 HTML 문서 전체를 서버로부터 전송받아야 했고, 이를 위해 페이지를 이동해야만 했다.
  - Ajax 덕분에 페이지를 이동하지 않고서도 Javascript로 서버와 데이터를 주고받을 수 있게 되었다.
- 2005년 구글 맵스가 이를 성공적으로 구현하면서 브라우저가 데스크톱 애플리케이션과 비교해도 UX가 손색이 없다는 것을 검증한다.

### 2.3.2 jQuery

- 서버에게 받은 데이터를 사용자가 볼 수 있게 하기 위해선 화면을 바꿔줘야 한다. 이를 위해 JS로 DOM에 접근해서 HTML element를 수정할 필요가 있었고, 더 간편하고 쉬운 수정을 위해 jQuery가 탄생하게 되었다.

### 2.3.3 V8 자바스크립트 엔진

- 구글 V8 자바스크립트 엔진으로 과거 웹 서버에서 수행되던 로직들이 클라이언트(브라우저)로 이동했고, 프론트엔드 복잡성이 엄청나게 증가했다.
- 이후 웹앱 개발에서 프론트엔드 영역이 주목받게 된다.

### 2.3.4 Node.js

- 2009년 발표된 Node.js는 V8 엔진으로 빌드된 JS 런타임 환경이다.
- 브라우저 이외의 환경에서도 JS를 실행할 수 있도록 독립시킨 실행 환경이며, 주로 백엔드 서버 사이드 개발에 사용된다.
- 비동기 I/O를 지원하며 single thread 이벤트 루프 기반으로 동작함으로써 Request 처리 성능이 좋다.
  - 데이터를 실시간으로 처리하기 위해 I/O가 빈번히 발생하는 Single Page Application에 좋다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.

### 2.3.5 SPA 프레임워크

- CBD (Component Based Development) 방법론을 기반으로 하는 SPA가 대중화되면서, Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리가 등장했다.

## 2.4 자바스크립트와 ECMAScript

- Javascript는 프로그래밍 언어 표준 문법인 ECMAScript와 브라우저가 별도 지원하는 Web API (DOM, BOM, Canvas, fetch, Web Storage 등)을 아우르는 개념이다.

## 2.5 자바스크립트의 특징

- JS는 브라우저에서 동작하는 유일한 프로그래밍 언어이다.
- 인터프리터 언어이고, 브라우저 엔진에서 컴파일러의 장점을 가져와 일부 파일을 컴파일한다.
- JS는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.
  - 간혹 클래스, 상속, 정보 은닉을 위한 키워드가 없어 객체지향 언어가 아니라고 오해받긴 하지만 JS는 프로토타입 기반 객체지향 언어다.

## 2.6 ES6 브라우저 지원 현황

- 구형 브라우저를 구려해야 하는 경우 Babel과 같은 트랜스파일러를 사용해 ES6 이상 코드를 ES5 이하에도 호환 가능하게 만들어야 한다.

# 3장 자바스크립트 개발 환경과 실행 방법

## 3.1 JS 실행 환경

- JS는 브라우저 또는 Node.js 환경에서 실행 가능하다. 단, 두 실행환경은 목적이 다르며 Node.js에서는 DOM 접근이나 Web API를 제공하지 않는다. 브라우저에서는 유저 파일 시스템 관련 기능을 제공하지 않는다.

### 3.2 웹 브라우저

- 크롬 브라우저 점유율 엄청나다
- 크롬 브라우저의 개발자 도구 DevTools
  - Sources 메뉴에서 디버깅 하는 방법이 궁금했는데 꽤 자세히 설명해준다.

### 3.3 Node.js npm

- npm, node package manager는 JS 모듈들을 패키지화해서 모아둔 저장소 역할 및 패키지 설치, 관리 가능한 CLI 제공한다.

### 3.4 VSCode

- 이걸 이렇게까지 자세히 설명해주다니.
- Code Runner 확장 / Live Server 확장

# 4장 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

- 변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다.
  - 값의 위치를 가리키는 상징적인 이름
- 변수에 값을 저장하는 것을 assignment 할당이라 하고, 저장된 값을 읽는 것을 reference 참조라 한다.

## 4.2 식별자

- 변수 이름을 식별자라고도 하며, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
- 식별자는 값 그 자체가 아닌 값이 저장된 메모리 주소를 기억하고 있다.

## 4.3 변수 선언

- variable declaration 변수 선언이란 변수를 생성하는 것이고, 메모리 공간을 확보하는 것이다.
- var, let, const로 선언 가능하다.
- 변수 선언만 하더라도 해당 메모리 공간에 JS 엔진에 의해 `undefined` 값이 암묵적으로 할당되어 초기화된다.
  - 변수 이름과 변수 값은 실행 컨텍스트 내에 key-value 형식 객체로 등록되어 관리된다. -> 13장 스코프와 23장 실행 컨텍스트에서 자세히 살펴볼 것.
- 선언하지 않은 식별자에 접근하면 `ReferenceError` 발생

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score); // undefined

var score;
```

- 변수 선언이 소스코드 실행 시점, 런타임이 아니라 그 이전에 먼저 실행되기 때문이다.
- 즉 JS 엔진은 변수 선언이 소스코드 어디에 있던 상관없이 다른 코드들보다 먼저 실행한다.
  - **변수 선언문이 코드 처음으로 끌어올려진 것처럼 동작하는 특징을 variable hoisting 변수 호이스팅이라 한다.**
  - 변수 선언 뿐 아니라, var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.

## 4.5 값의 할당

```js
var score;
score = 90;

var score = 90;
```

- JS 엔진은 변수 선언과 값의 할당을 하나의 명령문으로 단축 표현해도 2개의 문으로 나누어 각각 실행한다.
- 이때, **변수 선언은 런타임 이전에 실행되지만 값의 할당은 런타임에 실행된다.**

```js
console.log(score); // undefined

var score = 80;

console.log(score); // 80
```

![alt text](<image/Pasted image 20240918184047.png>)

- 변수에 값을 할당할 때는 새로운 메모리 공간을 확보하고 새로운 값을 할당한다.

```js
console.log(score); // undefined

score = 80;
var score;

console.log(score); // 80
```

## 4.6 값의 재할당

- 엄밀하게는 처음 할당도 undefined -> 다른 값이므로 재할당이다.
- const 키워드로 선언한 상수는 재할당이 금지된다.
- 재할당 시에도 새로운 메모리에 새로운 값을 할당한다.
- unmanaged language : C 언어 같은 개발자가 명시적으로 메모리 할당 및 해제를 해주어야 하는 언어
- managed language : 메모리 관리는 언어 차원에서 담당하고 개발자는 명시적으로 관여하지 않는 것

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자 제외한 문자, 숫자, 언더스코어(\_), 달러 기호(\$) 를 포함할 수 있다.
- 식별자가 숫자로 시작하는 것은 허용되지 않는다.
- 예약어는 식별자로 사용 불가능하다.
- 일반적으로 변수나 함수에는 카멜 케이스, 생성자 함수나 클래스는 파스칼 케이스를 사용한다.

# 5장 표현식과 문

## 5.1 값

- **값은 식이 평가되어 생성된 결과를 말한다.**
  - 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.
  - `10 + 20;` 식은 평가되어 숫자 값 30을 생성한다.
- 모든 값은 데이터 타입을 가진다.
- 변수에 할당되는 것은 값이다.

## 5.2 리터럴 literal

- **리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.**
- 정수, 소수, 2진수, 문자열, boolean, 함수 등을 메모리에 생성하기 위해 미리 약속된 표기들이다.

## 5.3 표현식

- **expression 표현식은 값으로 평가될 수 있는 statement 문이다.** 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- 리터럴은 값으로 평가되므로 리터럴도 표현식이다.
  - `var score = 100;` 에서 100은 리터럴이자 표현식이다.
  - 변수 식별자를 참조하는 것도 표현식이다.
- **값으로 평가될 수 있는 문은 모두 표현식이다.**

## 5.4 문

- **문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.**\
- 문은 여러 토큰으로 구성되며, 토큰은 문법적인 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- JS 엔진은 명령문의 끝이라고 예측되는 지점에 자동으로 세미콜론을 삽입해주는 ASI Automatic Semicolon Insertion을 수행하므로 꼭 세미콜론을 붙이지 않아도 잘 작동한다.
- 다만 개발자가 예측하지 못하는 세미콜론 자동 삽입이 일어날 수 있으므로, 붙여주는 것이 권장된다.

## 5.6 표현식인 문과 표현식이 아닌 문

- 표현식인 문과 표현식이 아닌 문을 구분하는 가장 간단한 방법은 변수에 할당해 보는 것이다.
  - 표현식이 아닌 문은 값으로 평가 불가능하므로 변수에 할당할 수 없다.
- `var x;`와 같은 변수 선언문은 표현식이 아니다. 따라서 다른 변수에 할당할 수 없다.
  - `var foo = var x; // SyntaxError`
- `x = 100;`과 같은 할당문은 표현식이다. 따라서 값처럼 사용 가능하다.
  - `var foo = x = 100; console.log(foo); // 100`
- 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력한다. 이를 완료 값이라 한다. 완료 값은 표현식 평가 결과가 아니므로, 다른 변수에 할당할 수도, 참조할 수도 없다.

# 6장 데이터 타입

# 7장 연산자

### 7.1.3 문자열 연결 연산자

- `+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외는 산술연산자이다.

# 8장 제어문

---

#2주차

# 9장 타입 변환과 단축 평가

## 9.1 타입 변환이란?

- JS의 모든 값은 타입을 가진다. 개발자가 의도적으로 타입 변환하는 것을 명시적 타입 변환 explicit coercion 또는 타입 캐스팅 Type casting 이라 한다.
- 개발자의 의도와는 상관없이 표현식 평가 도중에 JS 엔진이 암묵적으로 타입을 자동 변환하는 것을 암묵적 타입 변환 implicit coercion 또는 타입 강제 변환 Type coercion 이라 한다.
- 원시 값은 변경 불가능한 값이라 기존 원시 값을 직접 변경하는 것이 아니라, 타입 변환이 일어나면 기본 원시 값을 이용해 다른 타입의 새로운 원시 값을 생성하는 것이다.
  - 즉, 암묵적 타입 변환은 기존 변수에다 값을 재할당해서 변경하는 것이 아니라, 표현식을 평가할 때만 암묵적으로 변환해서 새로운 값으로 사용 후에 이 값은 버린다.

## 9.2 암묵적 타입 변환

### 9.2.1 문자열 타입으로 변환

- `+` 연산자의 피연산자 중 하나 이상이 문자열이라면, 문자열 연결 연산자로 동작한다.
  - 문자열 연결 연산자의 피연산자 중 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.
- 리터럴 표현식은 표현식 결과를 문자열로 암묵적 타입 변환한다.
  > Symbol type은 string으로 바꿀 수 없다.

### 9.2.2 숫자 타입으로 변환

- `-`, `*`, `/` 등의 산술 연산자의 피연산자는 모두 숫자 타입으로 암묵적 타입 변환되며, 피연산자를 변환할 수 없는 경우 표현식 평가 결과는 `NaN`이 된다.
- 비교 연산자도 숫자 타입으로 암묵적 타입 변환한다.

### 9.2.3 불리언 타입으로 변환

- 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.
- **자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.** - 명시적으로 false 값이 아니더라도 undefined, null, NaN등의 Falsy 값은 false로 평가된다.
  > [!question] 관련 퀴즈
  >
  > ```js
  > 0 == []; // true
  > 0 == "0"; // true
  > "0" == []; // false
  > ```
  >
  > - 배열은 number type으로 암시적 변환될 때 0으로 변환되는 반면, string type으로 암시적 변환될 때 "" 빈 문자열로 변환되기 때문에 위와 같은 결과가 나온다.

## 9.3 명시적 타입 변환

- 표준 빌트인 생성자 함수 / 빌트인 메서드 / 암묵적 타입 변환 이용

### 9.3.1 문자열 타입으로 변환

1. `String()` 생성자 함수 호출
2. `Object.prototype.toString` 메서드 이용
3. 문자열 연결 연산자를 통한 암묵적 타입 변환

### 9.3.2 숫자 타입으로 변환

1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
2. parselnt, parseFIoat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가늠)
3. `+` 단항 산술 연산자를 이용하는 방법
4. `*` 산술 연산자를 이용하는 방법

### 9.3.3 불리언 타입으로 변환

1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
2. ! 부정 논리 연산자를 두 번 사용하는 방법

## 9.4 단축 평가

> react에서 자주 쓰는 단축평가의 자세한 내용!

### 9.4.1 논리 연산자를 사용한 단축 평가

- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한 쪽으로 평가된다.

```js
"Cat" && "Dog"; // -> "Dog"
"Cat" || "Dog"; // -> "Cat"
```

- 좌항에서 우항으로 평가가 진행되는데, 논리곱의 경우 첫 항이 true인 경우 두 번째 피연산자가 논리곱 연산자 표현식 전체의 평가 결과를 결정한다.
  - 이때 논리곱 연산자는 **논리 연산의 결과를 결정하는 두 번째 피연산자를 그대로 반환**한다.
- 논리합 연산자는 첫 항이 true로 평가되는 경우 두 번째 피연산자까지 확인하지 않아도 전체 표현식은 true이다.

  - 이때 논리합 연산자는 첫 번째 피연산자를 그대로 반환한다.

- **단축 평가**란 **표현식 평가 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략**하는 걸 말한다.
  - 어떤 조건이 Truthy 값일 때 논리곱(&&) 연산자 표현식으로 if 문 대체 가능
  - 어떤 조건이 Falsy 값일 때 논리합(||) 연산자 표현식으로 if 문 대체 가능

> [!info] 객체가 null 또는 undefined가 아닌지 확인하고 객체의 프로퍼티 참조할 때 && 사용
>
> ```js
> var obj = null;
> var prop = obj.prop; // TypeError: Cannot read property 'prop' of null
>
> var prop = obj && obj.prop;
> var prop = obj?.prop; //ES11에서 새로 도입된 옵셔널 체이닝 연산자
> ```

> [!info] 함수 매개변수에 기본값을 설정할 때 || 사용
>
> - 함수 호출 시 인수 전달이 없으면 매개변수에 자동으로 undefined 할당
> - 단축 평가를 통해 매개변수 기본값 설정해서 undefined 방지
> - ES6부터는 매개변수 기본값을 `=` 연산자로 바로 설정 가능
>
> ```js
> function getStringLength(str) {
>   str = str || "";
>   return str.length;
> }
> getStringLength(); // => 0
>
> // ES6의 매개변수 기본값 설정 기능
> function getStringLength(str = "") {
>   return str.length;
> }
> getStringLength(); // => 0
> ```

### 9.4.2 옵셔널 체이닝 연산자 `?.`

- ES11에서 새로 도입
- 옵셔널 체이닝 연산자 앞의 객체가 null, undefined 라면 오류 대신 undefind 반환
  > [!NOTE] `&&` 와 `?.` 의 차이점
  >
  > - 논리 연산자 &&는 단축 평가를 통해 좌항이 Falsy 값(false, undefined, null, 0, -0, NaN, '')이면 좌항 피연산자를 그대로 반환한다.
  >   - 단, 0이나 ''은 객체로 평가될 때도 있다. (21.3절 참고)
  > - 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이어도 null 또는 undefined가 아니면 우항의 property 참조를 이어간다.

### 9.4.3 null 병합 연산자 `??`

- ES11에서 도입
- 좌항의 피연산자가 null, undefined라면 우항의 피연산자를 반환하고, 아니면 좌항의 피연산자를 반환
- 변수에 기본값을 설정할 때 유용

```js
let foo = null ?? "default string";
console.log(foo); // "default string"

foo = "hihi" ?? "default";
console.log(foo); // "hihi"
```

> [!NOTE] `||` 과 `??` 의 차이점
>
> - 논리연산자 `||`은 좌항의 피연산자가 `false`로 평가되는 Falsy 값이면 우항의 피연산자를 반환
> - 만약 Falsy 값인 0이나 ''도 유효한 기본값으로 두고 싶다면 `||`로는 추가 처리가 필요했지만, `??`를 사용하면 null, undefined만 걸러낼 수 있다.
>
> ```js
> let foo = "" || "default";
> console.log(foo); // "default"
>
> let foo = "" ?? "default";
> console.log(foo); // ""
> ```

# 10장 객체 리터럴

## 10.1 객체란?

- JS에서 **원시 값을 제외한 모든 나머지 값(함수, 배열, 정규 표현식 등)이 객체**이다.
- 원시 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다. (11장 참고)
- 객체는 0개 이상의 property로 구성된 집합이며, property는 key와 value로 구성된다.
- JS에서 사용 가능한 모든 값은 property 값이 될 수 있다.
  - JS의 함수는 "일급 객체 (18.1 절)" 이므로 값으로 취급할 수 있다. 따라서 함수도 property 값으로 사용 가능하다.
  - property 값이 함수일 경우, 일반 함수와의 구분을 위해 method라 부른다.

> [!info] 프로퍼티와 메서드
>
> - property : 객체의 상태를 나타내는 값 (data)
> - method : property를 참조하고 조작할 수 있는 동작 (behavior)

> [!abstract] 객체와 함수
>
> - JS의 객체는 함수와 밀접한 연관성을 가진다. 함수로 객체 생성하기도 하고, 함수 자체도 객체이다.
> - 객체의 집합으로 프로그램을 표현하려는 패러다임을 객체지향 프로그래밍이라 한다.(19.1절)

## 10.2 객체 리터럴에 의한 객체 생성

> [!abstract] 클래스 기반 객체지향 언어, 인스턴스
>
> - C++나 JAVA 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체 생성한다.
>   - 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 상태에 초첨을 맞춘 용어이다.
> - 참고 : [Javascript는 왜 함수형 Prototype을 선택했는가? 에 대한 철학적 논의](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)

- JS는 프로토타입 기반 객체지향 언어로, 다양한 객체 생성 방법을 지원한다.

  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스(ES6)

- 가장 일반적인 방식은 객체 리터럴 사용
  - JS는 new로 생성자를 호출할 필요 없이 객체 생성 가능하다.
- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.

```js
let person = {
  name: "Lee",
  sayHello: function () {
    console.log(`hello ${this.name}$`);
  },
};

let empty = {}; // 빈 객체
console.log(typeof empty); // object
```

- 객체 리터럴의 중괄호는 코드 블록이 아니다.
  - 값으로 평가되는 표현식이므로 닫는 중괄호 뒤에 세미콜론을 붙인다.
  - 코드 블록의 닫는 중괄호에는 세미콜론을 붙이지 않는다.

## 10.3 프로퍼티

> 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값 : JS에서 사용 가능한 모든 값

- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 사용

```js
let person = {
  firstName: "Jihwan", // 식별자 네이밍 준수
  "last-name": "Kim", // 식별자 네이밍 미준수
};
```

- 프로퍼티 키에 문자열이나 심벌 값 외의 숫자 값 등을 사용하면 암묵적 타입 변환으로 문자열이 된다.
- 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언된 프로퍼티가 먼저 선언된 프로퍼티를 덮어쓴다. error 발생하지 않음에 주의.
  - 스프레드 연산자와 함께 특정 프로퍼티 값만 변경하고 싶을 때 사용한 것 같다.

```js
let person = {
  name: "kim",
  age: "24",
};
person = { ...person, age: "25" }; // {name: 'kim', age: '25'}
```

## 10.4 메서드

- JS의 함수는 일급 객체로, 값으로 취급 가능하므로 프로퍼티 값으로도 사용 가능하다.
- 프로퍼티 값이 함수일 경우 일반 함수와 구분하여 method라 부른다.
- 메서드 내부에서 사용한 this 키워드는 객체 자신을 가리키는 참조변수가 된다.
  - 단, ES6의 화살표 함수에선 this 변수가 없기 때문에 선언 시점의 상위 스코프 this를 참조한다.
  - 참고 : [[JavaScript] 화살표 함수와 this 바인딩 (velog.io)](https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9#:~:text=%ED%99%94%EC%82%B4%ED%91%9C%20%ED%95%A8%EC%88%98%EB%8A%94)

## 10.5 프로퍼티 접근

- 마침표 프로퍼티 접근 연산자(`.`)를 사용하는 마침표 표기법
- 대괄호 프로퍼티 접근 연사자(`[ ... ]`)를 사용하는 대괄호 표기법
  - 대괄호 표기법을 사용하는 경우 **대괄호 프로퍼티 접근 연산자 내부에 지정하는 키는 반드시 따옴표로 감싼 문자열**이어야 한다.
    - 대괄호로 감싸지 않으면 식별자로 해석한다.
    - 프로퍼티 키가 숫자로 이뤄진 경우 따옴표 생략 가능

```js
let person = {
  name: "Lee",
};

console.log(person.name);
console.log(person["name"]);
```

- 객체에 존재하지 않는 프로퍼티에 접근하면 Reference Error가 아니라 undefined를 반환한다.

> [!info] Node 환경과 브라우저 환경에서의 다른 프로퍼티 접근 결과
>
> ```js
> let person = {
>   'last-name': 'Lee',
>   1: 10
> }
> person.last-name; // 브라우저 환경 -> NaN
> 				// Node.js 환경 : ReferenceError: name is not defined
> person.'last-name'; // SyntaxEror: Unexpected string
> person['last-name']; // Lee
>
> person.1; // SyntaxError: Unexpected number
> person.'1'; // SyntaxError: Unexpected string
> person[1]; //10
> person['1']; // 10
> ```
>
> - person.last-name을 실행하면 JS 엔진은 먼저 person.last를 평가하고, 프로퍼티가 없어 undefined로 평가된다.
> - 따라서 `person.last - name == undefined - name` 이 된다.
> - 다음으로 JS 엔진은 name이라는 식별자를 찾는다. Node.js에서는 name이라는 식별자 선언이 없어서 ReferenceError가 뜬다.
> - 그러나 브라우저에는 window 전역 객체의 프로퍼티로 name 전역 변수가 존재하고, 기본값은 빈 문자열이라 undefined - '' 이 되어 NaN 이 된다.

## 10.6 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 갱신된다.

## 10.7 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 선언 이후 동적으로 생성되어 추가된다.

## 10.8 프로퍼티 삭제

- `delete` 연산자는 객체 프로퍼티를 삭제한다. 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시된다.

## 10.9 ES6에서 추가된 객체 리터럴 확장 기능

### 10.9.1 프로퍼티 축약 표현

- ES6에서 프로퍼티 값으로 변수 사용하는 경우, 변수 이름과 프로퍼티 키가 동일 값으로 생성하고 싶다면 생략 가능하다.
  - 프로퍼티 키가 변수 이름으로 자동 생성된다.

```js
let x = 1,
  y = 2;
const obj = { x, y };
console.log(obj); // {x: 1, y: 2}
```

### 10.9.2 계산된 프로퍼티 이름

- 문자열 또는 문자열 타입 변환 가능한 값으로 평가되는 표현식을 써서 프로퍼티 키를 동적 생성 가능하다.
  - 단, 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 하고, 이를 계산된 프로퍼티 이름(computed property name)이라 한다.
- ES5에선 객체 리터럴 외부에서 대괄호를 써야 했으나 ES6부터 객체 리터럴 내부에서도 대괄호로 프로퍼티 키 동적 생성 가능하다.

```js
//ES6
const prefix = "prop";
let i = 0;

const obj = {
  //객체 리터럴 내부에서 생성
  [`${prefix} - ${++i}`]: i,
  [`${prefix} - ${++i}`]: i,
  [`${prefix} - ${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 10.9.3 메서드 축약 표현

- ES5에서 메서드 정의하려면 프로퍼티 값으로 함수 할당한다.
- ES6에선 메서드 정의 시 function 키워드 생략한 축약 표현 가능하다.
  - 메서드 축약 표현으로 정의한 메서드는 프로퍼티 할당한 함수와 다르게 동작한다. 26.2절 메서드에서 자세히 살펴봄

```js
// ES5
var obj = {
  name: "Lee",
  sayHi: function () {
    console.log("sayHi");
  },
};

// ES6
const obj = {
  name: "Lee",
  sayHi() {
    console.log("sayHi");
  },
};
```

# 11장 원시 값과 객체의 비교

- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.

- 원시 타입 문자열로 불변성 설명

- 문자열은 유사 배열 객체이면서 iterable이므로 배열과 유사한 방식으로 각 문자에 접근 가능하다.

### 11.1.3 값에 의한 전달

- 변수에 변수를 할당했을 때 원시 값이 복사되어 전달되는 것
  - 단, 엄밀히는 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문에 주의해야 한다.
  - "공유에 의한 전달"이라 표현하는 경우도 있다.
-

# 12장 함수

# 13장 스코프

# 14장 전역변수의 문제점

---

#3주차 15~19

# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

- ES5까지는 var로만 변수 선언이 가능했는데, var만의 특이한 특징들이 있다.

### 15.1.1 변수 중복 선언 허용

- var 키워드로 선언한 변수는 같은 스코프 내에서 중복 선언 가능하다.
- 초기화문이 있다면, JS 엔진에 의해 var 없는 것처럼 동작해서 변수 값이 변경된다. `var x = 100;`
- 초기화문이 없다면 무시된다. `var x;`

### 15.1.2 함수 레벨 스코프

- var 키워드는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 안이어도 모두 전역 변수가 된다.
- for 문의 변수 선언문에서 var로 선언한 변수도 전역 변수가 된다.

### 15.1.3 변수 호이스팅

- 변수 호이스팅(4.4절)에 의해 변수 선언이 미리 되어 `undefined`로 초기화된다.

## 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

- let 키워드로 이름 같은 변수 중복 선언하면 `SyntaxError` 발생

### 15.2.2 블록 레벨 스코프

- let 키워드로 선언된 변수는 모든 코드 블럭(함수, if 문, for 문, wihle 문, try/catch 문 등)을 지역 스코프로 인식한다. 즉, 지역 변수의 개념이 C언어와 동일해졌다.

### 15.2.3 변수 호이스팅

- let으로 선언된 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
  - 선언 이전에 참조하면 `ReferenceError`가 발생한다.
- var 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 한 번에 진행된다.
  - let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행된다.
  - 선언 단계는 JS 엔진에 의해 암묵적으로 먼저 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.

#### 일시적 사각지대 Temporal Dead Zone; TDZ

- let으로 선언한 변수는 스코프 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없는 구간이 존재한다. 이 구간을 TDZ라 부른다.
- 그러나 let 키워드로 선언한 변수도 호이스팅이 발생한다.

```js
// [예제 15-10]
let foo = 1;

{
  console.log(foo);
  let foo = 2;
}
```

- 호이스팅이 발생하지 않는다면, 전역 변수 foo의 값이 출력되어야 하나, 호이스팅이 발생해 지역 변수 foo에 대한 `ReferenceError` 발생
- **JS는 모든 선언(var, let, const, function, function\*, class 등)을 호이스팅한다.**

### 15.2.4 전역 객체와 let

- var 키워드로 선언한 전역 변수와 전역 함수, 암묵적 전역(21.4.3절)은 전역 객체 window의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.
- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo 로 접근할 수 없다.
  - let 전역 변수는 보이지 않는 개념적인 블록(23장 실행 컨텍스트) 내에 존재한다.

## 15.3 const 키워드

- const 키워드는 상수 선언을 위해 사용한다. 그런데 반드시 상수만을 위해 사용하지는 않는다.
-

# 16장 프로퍼티 어트리뷰트

# 17장 생성자 함수에 의한 객체 생성

# 18장 함수와 일급 객체

# 19장 프로토타입

- 프로토타입은 함수 원형이며, 유전자라 생각하면 편하다.

- 리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결된다.

- 객체가 다른 객체의 프로토타입을 참조하는 프로토타입 체인을 통해 상속이 이루어진다.
  - 메서드나 속성을 해당 객체에서 찾을 수 없으면, 프로토타입 체인을 따라 상위 프로토타입에서 검색한다

# 20장 strict mode

```js
function foo() {
  x = 10;
}
foo();

console.log(x); //
```

- 선언하지 않은 변수에 값을 할당할 때, 스코프 체인을 통해 검색하다가 전역 객체에 암묵적으로 x 프로퍼티를 동적 생성한다.

  - 이 현상이 **암묵적 전역** 이다.

- ES5부터 strict mode 추가되어서 JS 문법을 엄격히 적용해 문제 가능성이 있는 코드에 대해 명시적 에러 발생시킨다.
  - ES6에 도입된 클래스와 모듈은 기본적으로 strict mode 적용
  - 전역 선두나 함수 몸체 선두에 `'use strict';`를 추가해야 한다.
- ESLint와 같은 정적 분석 도구를 통해서도 유사한 효과를 얻을 수 있다.
  - 코딩 컨벤션도 정의할 수 있어 강력한 도구이다.
