# 1장 프로그래밍

## 1.1 프로그래밍이란?

- 컴퓨터를 원하는 방향으로 실행시키는 방법, 커뮤니케이션
- 무엇, 해결해야 할 문제, 요구사항을 먼저 정의해야 한다. 소프트웨어 공학이 생각나는 건 왜일까. Software Requirement Specification 작성 능력의 중요성
- 문제 해결 능력 : 알고리즘도 도움이 되며, 더 큰 범위의 능력.
- 대부분의 문제는 복잡하고 명확하지 않으므로 복잡한 것을 단순화하며 분해하고 구분 짓고 필요한 행위들을 잘 배열해내야 한다.
- 프로그래밍 : 정확하고 상세하게 요구사항을 설명하는 작업 -> 결과물로 코드가 나온다.
  - 이를 위해 컴퓨팅적 사고가 필요

## 1.2 프로그래밍 언어

- 컴퓨터에게 자연어가 아닌 기계어로 명령을 전달해야 한다. 다만 기계어는 인간이 이해하기 어려우므로 프로그래밍 언어로 작성하고, 컴파일러나 인터프리터를 통해 기계어로 번역된다.
- 프로그래밍 언어는 구문(Syntax)와 의미(Semantics)의 조합으로 표현된다. 컴퓨테이션 이론에서 배웠던 것들이 스쳐지나간다..

- 최근 LLM 및 ChatAI 들의 등장으로 프로그래밍 자체가 추상화되었다고 느낀다. 누구나 자신이 만들고 싶은 것, 해결하고 싶은 문제만 잘 쪼개어 설명한다면 코드를 짜는 것은 일반인도 가능한 시대가 되었다.

## 1.3 구문과 의미

- 노엄 촘스키 : 언어의 의미는 문맥에 있는 것이지 문법에 있는 것이 아니다
  - ex) Colorless green ideas sleep furiously
- 프로그래밍을 잘 하려면 단순히 문법만 지키는 것보단, 같은 개발자들끼리 문맥(code convention 등)을 정하고 해당 문맥 내에서 사용해야 잘 하는 것이라 볼 수 있겠다. 좋은 변수 이름을 만들고, 적당한 추상화를 하는 등.
- **프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것**이다.

# 2장 자바스크립트란?

## 2.1 자바스크립트의 탄생

- Netscape에서 브라우저에서 동작하는 경량 언어 도입하기로 하고, 1996년 Javascript로 명명한다.

## 2.2 자바스크립트의 표준화

- MS에서 Javascript 파생 버전인 JScript를 IE에 탑재하고, 표준화가 안 되면서 크로스 브라우징 이슈가 발생하기 시작했다.
- 1997년 비영리 표준화 기구 ECMA international 에서 ECMA-262, ECMAScript 1 표준화 사양을 발표했다.
  - 2015년 ES6에서 let/const, 클래스, 화살표 함수, promise, import/export 등 범용 프로그래밍 언어가 갖춰야 할 문법들이 많이 추가되었다.

## 2.3 자바스크립트 성장의 역사

### 2.3.1 Ajax

- 1999년 JS로 서버와 브라우저가 비동기적으로 데이터를 주고받을 수 있는 Ajax(Asynchronous Javascript and XML)가 등장했다.
  - 이전에는 정보를 주고받으려면 HTML 문서 전체를 서버로부터 전송받아야 했고, 이를 위해 페이지를 이동해야만 했다.
  - Ajax 덕분에 페이지를 이동하지 않고서도 Javascript로 서버와 데이터를 주고받을 수 있게 되었다.
- 2005년 구글 맵스가 이를 성공적으로 구현하면서 브라우저가 데스크톱 애플리케이션과 비교해도 UX가 손색이 없다는 것을 검증한다.

### 2.3.2 jQuery

- 서버에게 받은 데이터를 사용자가 볼 수 있게 하기 위해선 화면을 바꿔줘야 한다. 이를 위해 JS로 DOM에 접근해서 HTML element를 수정할 필요가 있었고, 더 간편하고 쉬운 수정을 위해 jQuery가 탄생하게 되었다.

### 2.3.3 V8 자바스크립트 엔진

- 구글 V8 자바스크립트 엔진으로 과거 웹 서버에서 수행되던 로직들이 클라이언트(브라우저)로 이동했고, 프론트엔드 복잡성이 엄청나게 증가했다.
- 이후 웹앱 개발에서 프론트엔드 영역이 주목받게 된다.

### 2.3.4 Node.js

- 2009년 발표된 Node.js는 V8 엔진으로 빌드된 JS 런타임 환경이다.
- 브라우저 이외의 환경에서도 JS를 실행할 수 있도록 독립시킨 실행 환경이며, 주로 백엔드 서버 사이드 개발에 사용된다.
- 비동기 I/O를 지원하며 single thread 이벤트 루프 기반으로 동작함으로써 Request 처리 성능이 좋다.
  - 데이터를 실시간으로 처리하기 위해 I/O가 빈번히 발생하는 Single Page Application에 좋다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.

### 2.3.5 SPA 프레임워크

- CBD (Component Based Development) 방법론을 기반으로 하는 SPA가 대중화되면서, Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리가 등장했다.

## 2.4 자바스크립트와 ECMAScript

- Javascript는 프로그래밍 언어 표준 문법인 ECMAScript와 브라우저가 별도 지원하는 Web API (DOM, BOM, Canvas, fetch, Web Storage 등)을 아우르는 개념이다.

## 2.5 자바스크립트의 특징

- JS는 브라우저에서 동작하는 유일한 프로그래밍 언어이다.
- 인터프리터 언어이고, 브라우저 엔진에서 컴파일러의 장점을 가져와 일부 파일을 컴파일한다.
- JS는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.
  - 간혹 클래스, 상속, 정보 은닉을 위한 키워드가 없어 객체지향 언어가 아니라고 오해받긴 하지만 JS는 프로토타입 기반 객체지향 언어다.

## 2.6 ES6 브라우저 지원 현황

- 구형 브라우저를 구려해야 하는 경우 Babel과 같은 트랜스파일러를 사용해 ES6 이상 코드를 ES5 이하에도 호환 가능하게 만들어야 한다.

# 3장 자바스크립트 개발 환경과 실행 방법

## 3.1 JS 실행 환경

- JS는 브라우저 또는 Node.js 환경에서 실행 가능하다. 단, 두 실행환경은 목적이 다르며 Node.js에서는 DOM 접근이나 Web API를 제공하지 않는다. 브라우저에서는 유저 파일 시스템 관련 기능을 제공하지 않는다.

### 3.2 웹 브라우저

- 크롬 브라우저 점유율 엄청나다
- 크롬 브라우저의 개발자 도구 DevTools
  - Sources 메뉴에서 디버깅 하는 방법이 궁금했는데 꽤 자세히 설명해준다.

### 3.3 Node.js npm

- npm, node package manager는 JS 모듈들을 패키지화해서 모아둔 저장소 역할 및 패키지 설치, 관리 가능한 CLI 제공한다.

### 3.4 VSCode

- 이걸 이렇게까지 자세히 설명해주다니.
- Code Runner 확장 / Live Server 확장

# 4장 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

- 변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다.
  - 값의 위치를 가리키는 상징적인 이름
- 변수에 값을 저장하는 것을 assignment 할당이라 하고, 저장된 값을 읽는 것을 reference 참조라 한다.

## 4.2 식별자

- 변수 이름을 식별자라고도 하며, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
- 식별자는 값 그 자체가 아닌 값이 저장된 메모리 주소를 기억하고 있다.

## 4.3 변수 선언

- variable declaration 변수 선언이란 변수를 생성하는 것이고, 메모리 공간을 확보하는 것이다.
- var, let, const로 선언 가능하다.
- 변수 선언만 하더라도 해당 메모리 공간에 JS 엔진에 의해 `undefined` 값이 암묵적으로 할당되어 초기화된다.
  - 변수 이름과 변수 값은 실행 컨텍스트 내에 key-value 형식 객체로 등록되어 관리된다. -> 13장 스코프와 23장 실행 컨텍스트에서 자세히 살펴볼 것.
- 선언하지 않은 식별자에 접근하면 `ReferenceError` 발생

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score); // undefined

var score;
```

- 변수 선언이 소스코드 실행 시점, 런타임이 아니라 그 이전에 먼저 실행되기 때문이다.
- 즉 JS 엔진은 변수 선언이 소스코드 어디에 있던 상관없이 다른 코드들보다 먼저 실행한다.
  - **변수 선언문이 코드 처음으로 끌어올려진 것처럼 동작하는 특징을 variable hoisting 변수 호이스팅이라 한다.**
  - 변수 선언 뿐 아니라, var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.

## 4.5 값의 할당

```js
var score;
score = 90;

var score = 90;
```

- JS 엔진은 변수 선언과 값의 할당을 하나의 명령문으로 단축 표현해도 2개의 문으로 나누어 각각 실행한다.
- 이때, **변수 선언은 런타임 이전에 실행되지만 값의 할당은 런타임에 실행된다.**

```js
console.log(score); // undefined

var score = 80;

console.log(score); // 80
```

![alt text](<image/Pasted image 20240918184047.png>)

- 변수에 값을 할당할 때는 새로운 메모리 공간을 확보하고 새로운 값을 할당한다.

```js
console.log(score); // undefined

score = 80;
var score;

console.log(score); // 80
```

## 4.6 값의 재할당

- 엄밀하게는 처음 할당도 undefined -> 다른 값이므로 재할당이다.
- const 키워드로 선언한 상수는 재할당이 금지된다.
- 재할당 시에도 새로운 메모리에 새로운 값을 할당한다.
- unmanaged language : C 언어 같은 개발자가 명시적으로 메모리 할당 및 해제를 해주어야 하는 언어
- managed language : 메모리 관리는 언어 차원에서 담당하고 개발자는 명시적으로 관여하지 않는 것

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자 제외한 문자, 숫자, 언더스코어(\_), 달러 기호(\$) 를 포함할 수 있다.
- 식별자가 숫자로 시작하는 것은 허용되지 않는다.
- 예약어는 식별자로 사용 불가능하다.
- 일반적으로 변수나 함수에는 카멜 케이스, 생성자 함수나 클래스는 파스칼 케이스를 사용한다.

# 5장 표현식과 문

## 5.1 값

- **값은 식이 평가되어 생성된 결과를 말한다.**
  - 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.
  - `10 + 20;` 식은 평가되어 숫자 값 30을 생성한다.
- 모든 값은 데이터 타입을 가진다.
- 변수에 할당되는 것은 값이다.

## 5.2 리터럴 literal

- **리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.**
- 정수, 소수, 2진수, 문자열, boolean, 함수 등을 메모리에 생성하기 위해 미리 약속된 표기들이다.

## 5.3 표현식

- **expression 표현식은 값으로 평가될 수 있는 statement 문이다.** 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- 리터럴은 값으로 평가되므로 리터럴도 표현식이다.
  - `var score = 100;` 에서 100은 리터럴이자 표현식이다.
  - 변수 식별자를 참조하는 것도 표현식이다.
- **값으로 평가될 수 있는 문은 모두 표현식이다.**

## 5.4 문

- **문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.**\
- 문은 여러 토큰으로 구성되며, 토큰은 문법적인 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- JS 엔진은 명령문의 끝이라고 예측되는 지점에 자동으로 세미콜론을 삽입해주는 ASI Automatic Semicolon Insertion을 수행하므로 꼭 세미콜론을 붙이지 않아도 잘 작동한다.
- 다만 개발자가 예측하지 못하는 세미콜론 자동 삽입이 일어날 수 있으므로, 붙여주는 것이 권장된다.

## 5.6 표현식인 문과 표현식이 아닌 문

- 표현식인 문과 표현식이 아닌 문을 구분하는 가장 간단한 방법은 변수에 할당해 보는 것이다.
  - 표현식이 아닌 문은 값으로 평가 불가능하므로 변수에 할당할 수 없다.
- `var x;`와 같은 변수 선언문은 표현식이 아니다. 따라서 다른 변수에 할당할 수 없다.
  - `var foo = var x; // SyntaxError`
- `x = 100;`과 같은 할당문은 표현식이다. 따라서 값처럼 사용 가능하다.
  - `var foo = x = 100; console.log(foo); // 100`
- 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력한다. 이를 완료 값이라 한다. 완료 값은 표현식 평가 결과가 아니므로, 다른 변수에 할당할 수도, 참조할 수도 없다.

# 6장 데이터 타입

# 7장 연산자

# 8장 제어문

```js
0 == []; //true
0 == "0"; //true
"0" == []; //true
```

# 9장 타입 변환과 단축 평가
