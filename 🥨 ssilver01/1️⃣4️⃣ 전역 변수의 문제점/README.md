# 1️⃣4️⃣ 전역 변수의 문제점

## 변수의 생명 주기

### 지역 변수의 생명 주기

- 지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.
- 변수 선언의 실행 시점과 변수 호이스팅
  - 변수 선언은 런타임 이전에 실행된다.
  - 변수 선언문 이전에 변수를 참조하면 참조 에러가 발생하지 않는다. - 변수 선언문 이전에 변수를 참조하면 `undefined`가 반환된다.
    => 변수 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 특징을 말한다.
- 지역 변수의 생명 주기는 변수 호이스팅과 밀접한 관련이 있다., 함수의 생명 주기와 일치한다.

### 전역 변수의 생명 주기

전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

## 전역 변수의 문제점

전역 변수는 생명 주기가 길기 때문에 메모리 리소스를 오랜 기간 소비하고, 전역 변수의 상태를 변경할 수 있는 시간도 길다.

- 스코프 체인 상에서 종점에 존재
  - 변수를 검색할 때 가장 마지막에 검색되기 때문에 검색 속도가 가장 느리다.
- 네임페이스 오염
  - 전역 변수는 코드 어디서든지 참조할 수 있기 때문에 어디서든지 전역 변수를 읽고 쓸 수 있다.
  - 다른 파일이나 라이브러리 등과의 충돌이 발생할 수 있다.

## 전역 변수의 사용을 억제하는 방법

변수의 스코프는 좁을수록 좋다. 전역 변수를 억제하는 방법은 다음과 같다.

- 즉시 실행 함수
  모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

  ```javascript
  (function () {
    var foo = 10;
    console.log(foo); // 10
  })();
  ```

- 네임스페이스 객체
  전역에 네임스페이스 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다.

  ```javascript
  var MYAPP = {};

  MYAPP.name = "Lee";
  console.log(MYAPP.name); // Lee
  ```

- 모듈 패턴
  모듈 패턴은 전역 변수를 억제하고 모듈 내부의 변수를 캡슐화할 수 있다.

  ```javascript
  var Counter = (function () {
    var num = 0;
    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
    return {
      increase() {
        return ++num;
      },
      decrease() {
        return --num;
      },
    };
  })();
  console.log(Counter.increase()); // 1
  console.log(Counter.increase()); // 2
  console.log(Counter.decrease()); // 1
  console.log(Counter.decrease()); // 0
  ```

- ES6 모듈
  ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
